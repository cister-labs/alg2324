\documentclass[aspectratio=169]{beamer}
\usepackage{etex} % fixes new-dimension error
\usepackage{lmodern}
\usepackage[T1]{fontenc}

\usepackage{graphicx,amsmath}
\usepackage{stmaryrd} % cf. interleave
\usepackage{booktabs}
\usepackage{amscd}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{alltt}
\usepackage{proof}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[new]{old-arrows}
\usepackage[all]{xy}
\usepackage{pgfplots}
\usepackage{textcomp}

\input{macros/macros}
%-------------- template --------------------------------------------------
\input{macros/beamerconf}
%----------------------------------------------------------------------------

\begin{document}

\setLecture{6}{Data Structures [WiP]}
\frame[plain]{\titlepage}


\begin{frame}[t]\frametitle{Overview}

  \begin{itemize}
    \item Stacks/Queues/PriorityQueues (\alert{minHeap})
    \item Hashtables/AVLs
    \item Graphs
    \begin{itemize}
      \item Detph/Breathfirst traversals
      \item Acyclic -- topological order
      \item Transitive closure
      \item Minimum spanning tree
      \item Shortest/longest path
    \end{itemize}
  \end{itemize}

  % transversal: dynamic programming?, greedy programming?

\end{frame}


\begin{frame}\frametitle{Motivation}
  \centering

  \begin{block}{We have seen that}
    Different \alert{data structures} are better at different \structure{operations}
  \end{block}

  \begin{block}{We will see}
    Useful data structures and associated operations (code)
  \end{block}

  \begin{exampleblock}{Examples}
    Arrays can have operations to implement sets, multisets, trees, etc.
  \end{exampleblock}

\end{frame}


\section{Sets and Sequences}

\begin{frame}[fragile]\frametitle{Sets and Multisets}
  
\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++,emph={SetInt,MSetInt}]
#define MAXS 100
typedef char SetInt [MAXS] ;
\end{lstlisting}

% \only<1>{
Given \texttt{SetInt s}:
\\$5 \in \texttt{s} ~\Leftrightarrow~ \texttt{s[5]!=0}$
% }
% \only<2->{
% \begin{lstlisting}[language=C++]
% void initSet (SetInt);
% int searchSet (SetInt , int);
% int addSet (SetInt, int);
% int emptySet (SetInt);
% void unionSet (SetInt , SetInt , SetInt );
% void intersectSet (SetInt , SetInt , SetInt );
% void differenceSet (SetInt , SetInt , SetInt );
% \end{lstlisting}
% }
\end{column}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++,emph={SetInt,MSetInt}]
#define MAXMS 100
typedef int MSetInt [MAXS] ;
\end{lstlisting}

% \only<1>{
Given \texttt{MSetInt ms}:
\\$\{4,4\} \subseteq \texttt{ms} ~\Leftrightarrow~ \texttt{ms[4]}\leq 2$
% }
% \only<2->{
% \begin{lstlisting}[language=C++]
% void initMSet ( MSetInt ) ; 
% int searchMSet ( MSetInt , int ) ;
% int addMSet ( MSetInt , int ) ;
% int emptyMSet ( MSetInt ) ;
% void unionMSet (MSetInt , MSetInt , SetInt );
% void intersectMSet (MSetInt , MSetInt , MSetInt ); 
% void differenceMSet (MSetInt , MSetInt , MSetInt );
% \end{lstlisting}
% }
\end{column}
\end{columns}

\end{frame}


\begin{frame}[fragile]\frametitle{Sets and Multisets -- operations}
\centering

\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++]
void initSet      (SetInt);
int  searchSet    (SetInt, int);
int  addSet       (SetInt, int);
int  emptySet     (SetInt);
void unionSet     (SetInt, SetInt,
                   SetInt);
void intersectSet (SetInt, SetInt,
                   SetInt);
void differenceSet(SetInt, SetInt,
                   SetInt);
\end{lstlisting}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++]
void initMSet      (MSetInt); 
int  searchMSet    (MSetInt, int);
int  addMSet       (MSetInt, int);
int  emptyMSet     (MSetInt);
void unionMSet     (MSetInt, MSetInt,
                    SetInt);
void intersectMSet (MSetInt, MSetInt,
                    MSetInt); 
void differenceMSet(MSetInt, MSetInt,
                    MSetInt);
\end{lstlisting}
%
\end{column}
\end{columns}

\doSimpleExercise{What is the expected cost of each function? Could you implement them?}
\end{frame}

\begin{frame}[fragile]\frametitle{Sequences -- Recall linked lists}
  
\begin{lstlisting}[language=C++,emph={list,LInt}]
typedef struct list { int value ;
struct list *next;
} *LInt;
\end{lstlisting}

  % add, remove, append, concat
\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++, emph={prev,LInt}]
LInt add (int x, LInt l) {
  LInt new =
    malloc(sizeof(struct list));
  if (new != NULL) {
    new->value=x;
    new->next=l ;
  }
return new;
}
\end{lstlisting}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++, emph={prev,LInt}]
LInt dda (int x, LInt l) {
  LInt pt = l;
  while (pt != NULL) pt = pt->next;
  pt = malloc(sizeof(struct list));
  pt -> next = x;
  pt -> next = NULL ;
  return l ;
}
\end{lstlisting}
%
\end{column}
\end{columns}
\end{frame}



\begin{frame}[fragile]\frametitle{Sequences -- Recall linked lists (fixed)}
  
\begin{lstlisting}[language=C++,emph={list,LInt}]
typedef struct list { int value ;
struct list *next;
} *LInt;
\end{lstlisting}

  % add, remove, append, concat
\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++, emph={prev,LInt}]
LInt add (int x, LInt l) {
  LInt new = malloc(sizeof(struct list ));
  if (new != NULL) {
    new->value=x;
    new->next=l ;
  }
return new;
}
\end{lstlisting}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++, emph={prev,LInt}]
LInt dda (int x, LInt l) {
  LInt pt = l, prev;
  while (pt != NULL) {
    prev = pt; pt = pt->next; }
  pt = malloc(sizeof(struct list));
  pt->next = x;
  pt->next = NULL ;
  if (l==NULL)  l = pt;
  else prev->prox = pt;
  return l;
}
\end{lstlisting}
%
\end{column}
\end{columns}

~\\[-6mm]
\doSimpleExercise{What is the possible complexity of 
  \texttt{lookup, concat, reverse}?
}
\end{frame}

\begin{frame}[fragile]\frametitle{Sequences -- reverse analysis}
  
\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++, emph={reverse1,reverse2,LInt}]
LInt reverse1 (LInt l) {
  LInt r, pt;
  if (l==NULL || l->next==NULL) r=l;
  else {
    r = pt = reverse1 (l->next);
    while (pt->next != NULL)
      pt = pt->next;
    pt->next = l;
    l->next = NULL;
  }
  return r; }
\end{lstlisting}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++, emph={reverse1,reverse2,LInt}]
LInt reverse2 (LInt l) {
  LInt r, tmp;
  r = NULL;
  while (l !=NULL) {
    tmp=l; l=l->next;
    tmp->next=r; r=tmp;
  }
  return r;
}
\end{lstlisting}
%
\end{column}
\end{columns}

~\\[-6mm]
\doSimpleExercise{What is the complexity of each \texttt{reverse}?}
~\\[-12mm]
\doSimpleExercise{What is the (informal) loop invariant in \texttt{reverse2}, assuming:
\\~~~ \texttt{pre:l==l$_0$} and \texttt{post:r==rev(l$_0$)}?}
% r==l0?  rev(l)++r == rev(l0)
\end{frame}


\begin{frame}\frametitle{Complexity of collections in Scala}
    
    \centering

    \begin{block}{}
    {\huge \url{https://docs.scala-lang.org/overviews/collections-2.13/performance-characteristics.html}}      
    \end{block}


\end{frame}


\section{Buffers (stacks and queueus)}


\begin{frame}[fragile]\frametitle{Stacks}

\begin{columns}
\begin{column}{.32\textwidth}
%
\begin{lstlisting}[language=C++, emph={stack,Stack}]
#define MAX 1000
typedef struct stack {
  int values [MAX];
  int sp;
} Stack;
\end{lstlisting}
\only<2->{with static arrays}
%
\end{column}
\begin{column}{.32\textwidth}
%
\begin{lstlisting}[language=C++, emph={stack,Stack}]
typedef struct cell {
  int value;
  struct cell *next;
} Cell , *Stack;
$~$
\end{lstlisting}
\only<2->{with linked lists}
%
\end{column}
\begin{column}{.32\textwidth}
%
\begin{lstlisting}[language=C++, emph={stack,Stack}]
typedef struct stack {
  int size ;
  int *values ;
  int sp;
} Stack;
\end{lstlisting}
\only<2->{with dynamic arrays}
%
\end{column}
\end{columns}
  

\only<2->{\doSimpleExercise{(Informally) what is the complexity of: \texttt{push}, \texttt{pop}, \texttt{head}?}}
  % with static arrays

  % with linked lists

  % with dynamic arrays (initStack, push/double, pop)

\end{frame}

\begin{frame}\frametitle{Queues}
    
  with static arrays (circular)

  with linked lists (store 2 pointers)
  
\end{frame}


\begin{frame}[fragile]\frametitle{Priority Queues}
      
  min-heap array

  example - how it can be used for a priority queue

\begin{lstlisting}[language=C++,emph={prQueue}]
#define MAX 1000
typedef struct prQueue {
  int values [MAX];
  int size ;
} PriorityQ ;
\end{lstlisting}

  exercises (bubble up, bubble down, complexity)

\end{frame}


\begin{frame}\frametitle{Exercises}
  
  \doExercise{Using the previous example, provide an expression to:}{
    \noindent
    \!\!1. calculate the index of the \emph{left} tree given a position \texttt{i}
    \\2. calculate the index of the \emph{right} tree given a position \texttt{i}
    \\3. calculate the index of the \emph{parent} of a given a position \texttt{i}
    \\4. calculate the index of the index of the \emph{first leaf}
  }

  \doExercise{Define \texttt{bubbleUp(int i, int h[])}}{
    Fixes a min-heap by swapping the \texttt{i}-th element with the parent while needed.
  }

  \doExercise{Define \texttt{bubbleDown(int i, int h[], int N)}}{
    Fixes a min-heap by swapping the \texttt{i}-th element with one of the children while needed.
  }
\end{frame}


\begin{frame}\frametitle{Exercises}
  \doExercise{Define the following operations:}{
    \noindent
    \!\!- \texttt{void empty (PriorityQueue *q)} -- initialises the queue;
    \\- \texttt{int isEmpty (PriorityQueue *q)} -- tests if \texttt{q} is empty;
    \\- \texttt{int add (int x, PriorityQueue *q)} -- adds a value \texttt{x}, returning 0 when the queue is full;
    \\- \texttt{int remove (PriorityQueue *q, int *rem)} -- removes the next element, and copies it to $rem$.
  }
\end{frame}


\end{document}
