\documentclass[aspectratio=169]{beamer}
\usepackage{etex} % fixes new-dimension error
\usepackage{lmodern}
\usepackage[T1]{fontenc}

\usepackage{graphicx,amsmath}
\usepackage{stmaryrd} % cf. interleave
\usepackage{booktabs}
\usepackage{amscd}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{alltt}
\usepackage{proof}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[new]{old-arrows}
\usepackage[all]{xy}
\usepackage{pgfplots}
\usepackage{textcomp}

\input{macros/macros}
%-------------- template --------------------------------------------------
\input{macros/beamerconf}
%----------------------------------------------------------------------------

\begin{document}

\setLecture{6}{Data Structures [WiP]}
\frame[plain]{\titlepage}


\begin{frame}[t]\frametitle{Overview}

  \begin{itemize}
    \item Stacks/Queues/PriorityQueues  %(\alert{minHeap})
    \item Hashtables/Search trees
    \item Graphs
    \begin{itemize}
      \item Depth/Breathfirst traversals
      \item Acyclic -- topological order
      \item Transitive closure
      \item Minimum spanning tree
      \item Shortest/longest path
    \end{itemize}
  \end{itemize}

  % transversal: dynamic programming?, greedy programming?

\end{frame}


\begin{frame}\frametitle{Motivation}
  \centering

  \begin{block}{We have seen that}
    Different \alert{data structures} are better at different \structure{operations}
  \end{block}

  \begin{block}{We will see}
    Useful data structures and associated operations (code)
  \end{block}

  \begin{exampleblock}{Examples}
    Arrays can have operations to implement sets, multisets, trees, etc.
  \end{exampleblock}

\end{frame}


\section{Sets and Sequences}

\begin{frame}[fragile]\frametitle{Sets and Multisets}
  
\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++,emph={SetInt,MSetInt}]
#define MAXS 100
typedef char SetInt [MAXS] ;
\end{lstlisting}

% \only<1>{
Given \texttt{SetInt s}:
\\$5 \in \texttt{s} ~\Leftrightarrow~ \texttt{s[5]!=0}$
% }
% \only<2->{
% \begin{lstlisting}[language=C++]
% void initSet (SetInt);
% int searchSet (SetInt , int);
% int addSet (SetInt, int);
% int emptySet (SetInt);
% void unionSet (SetInt , SetInt , SetInt );
% void intersectSet (SetInt , SetInt , SetInt );
% void differenceSet (SetInt , SetInt , SetInt );
% \end{lstlisting}
% }
\end{column}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++,emph={SetInt,MSetInt}]
#define MAXMS 100
typedef int MSetInt [MAXS] ;
\end{lstlisting}

% \only<1>{
Given \texttt{MSetInt ms}:
\\$\{4,4\} \subseteq \texttt{ms} ~\Leftrightarrow~ \texttt{ms[4]}\leq 2$
% }
% \only<2->{
% \begin{lstlisting}[language=C++]
% void initMSet ( MSetInt ) ; 
% int searchMSet ( MSetInt , int ) ;
% int addMSet ( MSetInt , int ) ;
% int emptyMSet ( MSetInt ) ;
% void unionMSet (MSetInt , MSetInt , SetInt );
% void intersectMSet (MSetInt , MSetInt , MSetInt ); 
% void differenceMSet (MSetInt , MSetInt , MSetInt );
% \end{lstlisting}
% }
\end{column}
\end{columns}

\end{frame}


\begin{frame}[fragile]\frametitle{Sets and Multisets -- operations}
\centering

\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++,emph={MSetInt,SetInt}]
void initSet      (SetInt);
int  searchSet    (SetInt, int);
int  addSet       (SetInt, int);
int  emptySet     (SetInt);
void unionSet     (SetInt, SetInt,
                   SetInt);
void intersectSet (SetInt, SetInt,
                   SetInt);
void differenceSet(SetInt, SetInt,
                   SetInt);
\end{lstlisting}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++,emph={MSetInt,SetInt}]
void initMSet      (MSetInt); 
int  searchMSet    (MSetInt, int);
int  addMSet       (MSetInt, int);
int  emptyMSet     (MSetInt);
void unionMSet     (MSetInt, MSetInt,
                    SetInt);
void intersectMSet (MSetInt, MSetInt,
                    MSetInt); 
void differenceMSet(MSetInt, MSetInt,
                    MSetInt);
\end{lstlisting}
%
\end{column}
\end{columns}

\doSimpleExercise{What is the expected cost of each function? Could you implement them?}
\end{frame}

\begin{frame}[fragile]\frametitle{Sequences -- Recall linked lists}
  
\begin{lstlisting}[language=C++,emph={list,LInt}]
typedef struct list { int value ;
struct list *next;
} *LInt;
\end{lstlisting}

  % add, remove, append, concat
\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++, emph={prev,LInt}]
LInt add (int x, LInt l) {
  LInt new =
    malloc(sizeof(struct list));
  if (new != NULL) {
    new->value=x;
    new->next=l ;
  }
return new;
}
\end{lstlisting}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++, emph={prev,LInt}]
LInt dda (int x, LInt l) {
  LInt pt = l;
  while (pt != NULL) pt = pt->next;
  pt = malloc(sizeof(struct list));
  pt -> next = x;
  pt -> next = NULL ;
  return l ;
}
\end{lstlisting}
%
\end{column}
\end{columns}
\end{frame}



\begin{frame}[fragile]\frametitle{Sequences -- Recall linked lists (fixed)}
  
\begin{lstlisting}[language=C++,emph={list,LInt}]
typedef struct list { int value ;
struct list *next;
} *LInt;
\end{lstlisting}

  % add, remove, append, concat
\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++, emph={prev,LInt}]
LInt add (int x, LInt l) {
  LInt new = malloc(sizeof(struct list ));
  if (new != NULL) {
    new->value=x;
    new->next=l ;
  }
return new;
}
\end{lstlisting}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++, emph={prev,LInt}]
LInt dda (int x, LInt l) {
  LInt pt = l, prev;
  while (pt != NULL) {
    prev = pt; pt = pt->next; }
  pt = malloc(sizeof(struct list));
  pt->next = x;
  pt->next = NULL ;
  if (l==NULL)  l = pt;
  else prev->prox = pt;
  return l;
}
\end{lstlisting}
%
\end{column}
\end{columns}

~\\[-6mm]
\doSimpleExercise{What is the possible complexity of 
  \texttt{lookup, concat, reverse}?
}
\end{frame}

\begin{frame}[fragile]\frametitle{Sequences -- reverse analysis}
  
\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++, emph={reverse1,reverse2,LInt}]
LInt reverse1 (LInt l) {
  LInt r, pt;
  if (l==NULL || l->next==NULL) r=l;
  else {
    r = pt = reverse1 (l->next);
    while (pt->next != NULL)
      pt = pt->next;
    pt->next = l;
    l->next = NULL;
  }
  return r; }
\end{lstlisting}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++, emph={reverse1,reverse2,LInt}]
LInt reverse2 (LInt l) {
  LInt r, tmp;
  r = NULL;
  while (l !=NULL) {
    tmp=l; l=l->next;
    tmp->next=r; r=tmp;
  }
  return r;
}
\end{lstlisting}
%
\end{column}
\end{columns}

~\\[-6mm]
\doSimpleExercise{What is the complexity of each \texttt{reverse}?}
~\\[-12mm]
\doSimpleExercise{What is the (informal) loop invariant in \texttt{reverse2}, assuming:
\\~~~ \texttt{pre:l==l$_0$} and \texttt{post:r==rev(l$_0$)}?}
% r==l0?  rev(l)++r == rev(l0)
\end{frame}


\begin{frame}\frametitle{Complexity of collections in Scala}
    
    \centering

    \begin{block}{}
    {\huge \url{https://docs.scala-lang.org/overviews/collections-2.13/performance-characteristics.html}}      
    \end{block}


\end{frame}


\section{Buffers (stacks and queueus)}


\begin{frame}[fragile]\frametitle{Stacks}

\begin{columns}
\begin{column}{.32\textwidth}
%
\begin{lstlisting}[language=C++, emph={stack,Stack}]
#define MAX 1000
typedef struct stack {
  int values [MAX];
  int sp;
} Stack;
\end{lstlisting}
\only<2->{with static arrays}
%
\end{column}
\begin{column}{.32\textwidth}
%
\begin{lstlisting}[language=C++, emph={stack,Stack}]
typedef struct cell {
  int value;
  struct cell *next;
} Cell , *Stack;
$~$
\end{lstlisting}
\only<2->{with linked lists}
%
\end{column}
\begin{column}{.32\textwidth}
%
\begin{lstlisting}[language=C++, emph={stack,Stack}]
typedef struct stack {
  int size;
  int *values;
  int sp;
} Stack;
\end{lstlisting}
\only<2->{with dynamic arrays}
%
\end{column}
\end{columns}
  

\only<2->{\doSimpleExercise{(Informally) what is the complexity of: \texttt{push}, \texttt{pop}, \texttt{head}?}}
  % with static arrays

  % with linked lists

  % with dynamic arrays (initStack, push/double, pop)

\end{frame}

\begin{frame}[fragile]\frametitle{Exercise: Push-pop with dynamic arrays}
    

\begin{columns}
\begin{column}{.48\textwidth}
\begin{lstlisting}[language=C++, emph={push,pop,doubleArray,realloc}]
void push (Stack *s , int x){
  if (s->sp == s->size)
    doubleArray (s);
  if (r == 0)
    s->values[s->sp++] = x;
}

void doubleArray (Stack *s){
  s->size *= 2;
  s->values =
    realloc(s->values, s->size);
}
\end{lstlisting}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++, emph={push,pop,doubleArray,realloc}]
int pop (Stack *s){
  // reduces by half when only
  // 25% capacity is used
  ...
}

void halfArray (Stack *s){
  ...
}
\end{lstlisting}
%
\end{column}
\end{columns}

\doSimpleExercise{Implement the optimised \texttt{pop} function and discuss its complexity.}

\end{frame}



\begin{frame}[fragile]\frametitle{Queues}
    
\begin{columns}
\begin{column}{.29\textwidth}
%
\begin{lstlisting}[language=C++, emph={queue,Queue}]
#define MAX 1000
typedef struct queue
{
  int values [MAX];
  int start, size;
} Queue;
$~$
$~$
\end{lstlisting}
\only<2->{with static arrays (circular)}
%
\end{column}
\begin{column}{.37\textwidth}
%
\begin{lstlisting}[language=C++, emph={cell,Cell,Queue}]
typedef struct cell {
  int value ;
  struct cell *prox ;
} Cell ;

typedef struct queue {
  struct cell *start, *end;
} Queue;
\end{lstlisting}
\only<2->{with linked lists\\~}
%
\end{column}
\begin{column}{.29\textwidth}
%
\begin{lstlisting}[language=C++, emph={queue,Queue}]
typedef struct queue
{
  int max;
  int *values;
  int start, size;
} Queue;
$~$
$~$
\end{lstlisting}
\only<2->{with dynamic arrays (circular)}
%
\end{column}
\end{columns}

\only<2->{\doSimpleExercise{(Informally) what is the complexity of: \texttt{init}, \texttt{isEmpty}, \texttt{enqueue}, \texttt{dequeue}?}}

\end{frame}



% \begin{frame}\frametitle{Queues}
    
%   with static arrays (circular)

%   with linked lists (store 2 pointers)
  
% \end{frame}


\begin{frame}[fragile]\frametitle{Priority Queues}
\begin{columns}
\begin{column}{.48\textwidth}
%
\begin{itemize}
  \item Binary tree
  \item Each node is larger than any of its children
  \item Implemented as an array
\end{itemize}
%
\end{column}
\begin{column}{.50\textwidth}
%
\begin{lstlisting}[language=C++,emph={prQueue}]
#define MAX 1000
typedef struct prQueue {
  int values [MAX];
  int size ;
} PriorityQ ;
\end{lstlisting}
%
\end{column}
\end{columns}


\bigskip

  \begin{exampleblock}{Tree example in the board}
    \centering
    \texttt{size=17~}%
    \textcolor{black!40}{%
    \texttt{~~0~~1~~2~~3~~4~~5~~6~~7~~8~~9 10 11 12 13 14 15 16~}}
    \\\texttt{values:~~}%
    \texttt{[10 15 11 16 22 35 20 21 23 34 37 80 43 22 25 24 28]}
  \end{exampleblock}
  % 10
  % 15 11
  % 16 22 35 20...

  % exercises (bubble up, bubble down, complexity)

\end{frame}


\begin{frame}\frametitle{Exercises}
  
  \doExercise{Using the previous example, provide an expression to:}{
    \noindent
    \!\!1. calculate the index of the \emph{left} tree given a position \texttt{i} % 2i+1
    \\2. calculate the index of the \emph{right} tree given a position \texttt{i} % 2i+2
    \\3. calculate the index of the \emph{parent} of a given a position \texttt{i} % (i-1)/2
    \\4. calculate the index of the index of the \emph{first leaf}
  }

  \doExercise{Define \texttt{bubbleUp(int i, int h[])}}{
    Fixes a min-heap by swapping the \texttt{i}-th element with the parent while needed.
  }

  \doExercise{Define \texttt{bubbleDown(int i, int h[], int N)}}{
    Fixes a min-heap by swapping the \texttt{i}-th element with one of the children while needed.
  }
\end{frame}


\begin{frame}\frametitle{Exercises}
  \doExercise{Define the following operations:}{
    \noindent
    \!\!- \texttt{void empty (PriorityQueue *q)} -- initialises the queue;
    \\- \texttt{int isEmpty (PriorityQueue *q)} -- tests if \texttt{q} is empty;
    \\- \texttt{int add (int x, PriorityQueue *q)} -- adds a value \texttt{x}, returning 0 when the queue is full;
    \\- \texttt{int remove (PriorityQueue *q, int *rem)} -- removes the next element, and copies it to $rem$.
  }
\end{frame}


\section{Dictionaries}

\begin{frame}\frametitle{Hashtables}

\alert{Dictionary:} maps \structure{keys} to \structure{values}
\\
(Keys are unique)

\begin{block}{Idea}
  - \alert{\emph{Magic} function \texttt{hash}} converts a key into an \structure{index} (number).
  \\- This \structure{index} points to the position of an array where the value \emph{should} be found.
  \\- Usually the size of the array is \alert{less} than the set of possible keys, i.e., \structure{\texttt{hash} is not injective}.
  \\- If 2 keys have the same \texttt{hash} value, there is a \alert{colision} that must be mitigated (alternative solutions exist).
\end{block}

\end{frame}


\begin{frame}\frametitle{Hashtables: Closed and Open Addressing}

\begin{columns}
  \begin{column}{0.48\textwidth}
    \begin{alertblock}{Closed Addressing (or chaining)}
      - Table = \emph{array of linked lists}
      \\
      - Find value of key \alert{\texttt{k}}:
      \\~~~- go to index \texttt{hash(k)}
      \\~~~- traverse list until \texttt{k}
    \end{alertblock}
  \end{column}
  \begin{column}{0.48\textwidth}
    \begin{exampleblock}{Open Addressing}
      - Table = \emph{just an array}
      \\
      - Find value of key \alert{\texttt{k}}:
      \\~~~- go to index \texttt{hash(k)}
      \\~~~- \emph{``jump''} until \texttt{k}
    \end{exampleblock}
  \end{column}
\end{columns}

\bigskip

\begin{block}{Some concerns}
  - Use dynamic arrays (grow when the \alert{load factor} (\#keys/HSIZE) gets high)
  \\~~~-Need to \emph{rehash}  
  \\- Smart \emph{jumps} (\texttt{probe} function to know where to jump)
  \\- Need to \emph{garbage collect} in open addressing
\end{block}

\end{frame}


\begin{frame}\frametitle{Intuition: Hashtables with Closed Addressing}
  \centering
  \includegraphics[width=0.6\textwidth]{images/HT-closed.png}
  \\
  {\footnotesize \textcolor{gray}{(from Wikipedia)}}
\end{frame}

\begin{frame}[fragile]\frametitle{Hashtables with Closed Addressing}
\begin{columns}
\begin{column}{.61\textwidth}
%
\begin{itemize}
  \item \texttt{int hash(\alert{\texttt{int}} k, int size);}
  \item \texttt{void initTab(HTChain h);}
  \item \texttt{int lookup(HTChain h, \alert{\texttt{int}} k, int *i);}
  \item \texttt{int update(HTChain h, \alert{\texttt{int}} k, int i);}
  \item \texttt{int remove(HTChain h, \alert{\texttt{int}} k);}
\end{itemize}
%
\end{column}
\begin{column}{.34\textwidth}
%
\begin{lstlisting}[language=C++,emph={HTChain,Bucket}]
#define HSIZE 1000

typedef struct bucket {
  $\alert{\texttt{int}}$ key;
  int info;
  struct bucket *next;
} *Bucket;

typedef Bucket
   HTChain[HSIZE];
\end{lstlisting}
%
\end{column}
\end{columns}

\doSimpleExercise{Implement \texttt{lookup}}
  % int p = hash (k,HSIZE); Bucket it;
  % for (it = h[p]; it!=NULL && it->key!=k; it=it->next);
  % if (it!=NULL) { *i = it->info; return 1;}
  % else return 0;
~\\[-10mm]
\doSimpleExercise{(Informally) what is the expected complexity of each function?}
\end{frame}


\begin{frame}\frametitle{Intuition: Hashtables with Open Addressing}
  \centering
  ~\\[-12mm]
  \includegraphics[width=0.6\textwidth]{images/HT-open.png}
  \\
  {\footnotesize \textcolor{gray}{(from Wikipedia)}}
\end{frame}


\begin{frame}[fragile]\frametitle{Hashtables with Open Addressing}
\begin{columns}
\begin{column}{.71\textwidth}
%
\begin{itemize}
  \item \texttt{int hash(\alert{\texttt{int}} k, int size);}
  \item \texttt{void initTab(HashTable h);}
  \item \texttt{void lookup(HashTable h, \alert{\texttt{int}} k, int *i);}
  \item \texttt{void update(HashTable h, \alert{\texttt{int}} k, int i);}
  \item \textcolor{black!40}{
          \texttt{void remove(HashTable h, \alert{\texttt{int}} k);}}
  \item \structure{
          \texttt{int find\_probe (HashTable h, \alert{\texttt{int}} k)}}
          \\~~~- linear vs. quadratic probing (why quadratic?)
\end{itemize}
%
\end{column}
\begin{column}{.34\textwidth}
%
\begin{lstlisting}[language=C++,emph={HashTable,Bucket}]
#define HSIZE 1000
#define STATUSFREE 0
#define STATUSUSED 1

typedef struct bucket {
  int status ;
  $\alert{\texttt{int}}$ key;
  int info;
} Bucket ;

typedef Bucket
  HashTable [HSIZE];
\end{lstlisting}
%
\end{column}
\end{columns}

~\\[-7mm]
\doSimpleExercise{Define a linear probing function and \texttt{update}.}
% ~\\[-10mm]
% \doSimpleExercise{(Informally) what is the expected complexity of each function?}
\end{frame}



\begin{frame}\frametitle{Lookups: Open vs. Closed}
  \centering
  \includegraphics[width=0.6\textwidth]{images/HT-lookups.png}
  \\
  {\footnotesize \textcolor{gray}{(from Wikipedia)}}
\end{frame}
    




\begin{frame}[fragile]\frametitle{Removing with Open Addressing}
\begin{columns}
\begin{column}{.71\textwidth}
%
\begin{itemize}
  \item \textcolor{black!40}{\texttt{int hash(\alert{\texttt{int}} k, int size);}}
  \item \textcolor{black!40}{\texttt{void initTab(HashTable h);}}
  \item \textcolor{black!40}{\texttt{void lookup(HashTable h, \alert{\texttt{int}} k, int *i);}}
  \item \textcolor{black!40}{\texttt{void update(HashTable h, \alert{\texttt{int}} k, int i);}}
  \item \textcolor{black!40}{\texttt{int find\_probe (HashTable h, \alert{\texttt{int}} k);}}
  \item \texttt{void \structure{remove}(HashTable h, \alert{\texttt{int}} k);}
\end{itemize}
%%% find_probe gets more complex.
%
\end{column}
\begin{column}{.34\textwidth}
%
\begin{lstlisting}[language=C++,emph={HashTable,Bucket}]
#define HSIZE 1000
#define STATUSFREE 0
#define STATUSUSED 1
#define $\structure{\texttt{STATUSDEL 2}}$

typedef struct bucket {
  int status ;
  $\alert{\texttt{int}}$ key;
  int info;
} Bucket ;

typedef Bucket
  HashTable [HSIZE];
\end{lstlisting}
%
\end{column}
\end{columns}

~\\[-6mm]
\doSimpleExercise{How would you implement \texttt{update}?
% ~\\[-12mm]
% \doSimpleExercise{
\\How would you implement a \emph{garbageCollect} that removes deleted cells? 
\\What is their complexity?}
\end{frame}

% \section{Balanced trees}

\begin{frame}\frametitle{More dictionaries: balanced trees}

\begin{block}{We will see:}
  - Height- and weight-balanced tree
  \\- Self-balancing binary search tree
  \\~~~- AVL tree
  % Adelson-Velsky and Landis
  % oldest self-balancing binary search tree data structure to be invented.
% \begin{tabular}{lcc}
% \toprule
% Function &  Amortized & Worst Case
% \\\midrule
% Search     & ${\Theta(\log n)}$ & ${\mathcal{O}(\log n)}$\\
% Insert     & ${\Theta(\log n)}$ & ${\mathcal{O}(\log n)}$\\
% Delete     & ${\Theta(\log n)}$ & ${\mathcal{O}(\log n)}$\\
% \bottomrule
% \end{tabular}
  \\~~~- Red-black tree
  %  It requires in the worst case a small number, O(log n) in Big O notation, where nn is the number of objects in the tree, on average or amortized O(1), a constant number, of color changes (which are very quick in practice); and no more than three tree rotations (two for insertion).
  % As of Java 8, the HashMap has been modified such that instead of using a LinkedList to store different elements with colliding hashcodes, a red–black tree is used.
% \toprule
% Function &  Amortized & Worst Case
% \\\midrule
% Search     & ${\mathcal{O}(\log n)}$ & ${\mathcal{O}(\log n)}$\\
% Insert     & ${\mathcal{O}(1)}$ & ${\mathcal{O}(\log n)}$\\
% Delete     & ${\mathcal{O}(1)}$ & ${\mathcal{O}(\log n)}$\\
% \bottomrule
% \end{tabular}
\end{block}

% [Binary Search Trees / AVL (self) / B-Tree / Red-Black]

\end{frame}


\begin{frame}\frametitle{Binary Balanced Search Trees}

  \begin{columns}[t]
  \begin{column}{0.48\textwidth}
    \begin{block}{Height-balanced}
      - more used
      \\- left-height = right-height ± 1 (AVL)
      \\- height = $\log n$
    \end{block}      
  \end{column}    
  \begin{column}{0.48\textwidth}
    \begin{block}{Weight-balanced}
      - less used
      \\- $\text{leafs-left/right} \geq \alpha \times \text{leafs}$, $0<\alpha<1$
    \end{block}      
  \end{column}    
  \end{columns}    


\end{frame}

\section{Graphs}

\begin{frame}\frametitle{Overview}
    
  \begin{itemize}
    \item Depth/Breathfirst traversals
    \item Acyclic -- topological order
    \item Transitive closure
    \item Minimum spanning tree
    \item Shortest/longest path
  \end{itemize}

\end{frame}

\end{document}
