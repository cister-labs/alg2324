\documentclass[aspectratio=169]{beamer}
\usepackage{etex} % fixes new-dimension error
\usepackage{lmodern}
\usepackage[T1]{fontenc}

\usepackage{graphicx,amsmath}
\usepackage{stmaryrd} % cf. interleave
\usepackage{booktabs}
\usepackage{amscd}
\usepackage{multicol}
\usepackage[absolute,overlay]{textpos}
\usepackage{alltt}
\usepackage{proof}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage[new]{old-arrows}
\usepackage[all]{xy}
\usepackage{pgfplots}
\usepackage{textcomp}

\input{macros/macros}
%-------------- template --------------------------------------------------
\input{macros/beamerconf}
%----------------------------------------------------------------------------

\begin{document}

\setLecture{3}{Counting steps\\~~~(Asymptotic analysis) [WiP]}
\frame[plain]{\titlepage}


\begin{frame}[t]\frametitle{Overview}

  % \begin{itemize}
  %   \item Measuring \structure{precisely} performance of algorithms
  %   \item Measuring \alert{asymptotically} performance of algorithms
  %   \item Measuring precisely the \alert{average time} of algorithms
  %   \item Next: beyond worst-/best-case scenarios
  %         \begin{itemize}
  %           \item Analysing \alert{recursive} functions
  %           \item Analysis of sequences of operations (\alert{amortised analysis})
  %         \end{itemize}
  % \end{itemize}

  \begin{itemize}
    \item Measuring \structure{precisely} performance of algorithms
    \item Measuring \alert{asymptotically} performance of algorithms
    \item Analysing \alert{recursive} functions
    \item Next: beyond worst-/best-case scenarios
          \begin{itemize}
            \item \alert{average time} of a single operation
            \item analysis of sequences of operations (\alert{amortised analysis})
          \end{itemize}
    \end{itemize}
\end{frame}

\section{Motivation}

\byothers{Charles E. Leiserson}{3-19}{Cormen_Algorithms_Slides.pdf}

\byothers{Pedro Ribeiro, slides 2}{1-2}{ribeiro/2_asymptoticanalysis_02102018.pdf}
\byothers{Pedro Ribeiro, slides 2}{8-18}{ribeiro/2_asymptoticanalysis_02102018.pdf}

\begin{frame}\frametitle{Next steps}
  \begin{enumerate}
    \item Precise analysis: \alert{counting operations}
    \item Approximate analysis -- \structure{Asymptotic notation }$(O, \Theta, \Omega, o, \omega)$
  \end{enumerate}
\end{frame}

\section{Counting operations}

% \begin{frame}[t]\frametitle{Exercises}
%   [WiP: bubble sort, iSort, mult1, mult2]

%   [Recall arithmetic and geometric series, height of binary tree, ...]

%   [Proceed with Pedro's slides]
% \end{frame}

\begin{frame}[fragile]\frametitle{Simpler counting}
\centering

\begin{lstlisting}[language=C++,linewidth=50mm]
int count = 0;
for (int i=0; i<n; i++)
  if (v[i] == 0) count++
\end{lstlisting}    

\frsplitt{
  \begin{block}{RAM}
  \begin{itemize}
    \item worst-case: $T(n) = 5+5n$
    \item best-case: $T(n) = 5+4n$
  \end{itemize}  
  \end{block}
}{
  \begin{alertblock}{\#array-accesses + \#count-increments}
  \begin{itemize}
    \item worst-case: $T(n) = 2n$
    \item best-case: $T(n) = n$
    \item \textcolor{black!30}{
      average-case: $\overline{T}(n) = n + \sum_{0\leq r < n}P(v[r]=0)$}
  \end{itemize}  
  \end{alertblock}
  
}
% 8kB
\end{frame}

\begin{frame}[fragile]\frametitle{Exercises}
  
\begin{columns}
\begin{column}{0.48\textwidth}
\begin{lstlisting}[language=C++]
void bubbleSort(int v[], int N){
  int i, j;
  for (i=N-1; i>0; i--)
    for (j=0; j<i; j++)
      if (v[j] > v[j+1]) swap(v,j,j+1);
}
\end{lstlisting}
\end{column}
\begin{column}{0.48\textwidth}
\begin{lstlisting}[language=C++]
void iSort(int v[], int N){
  int i, j;
  for (i=1; i<N; i++)
    for (j=i; j>0 && v[j-1]>v[j];
         j--)
      swap(v,j,j-1);
}
\end{lstlisting}
\end{column}
\end{columns}

\doSimpleExercise{What is the best and worst case wrt comparisons between array elements?}
~\\[-12mm]
\doSimpleExercise{What is the best and worst case wrt swaps?}
~\\[-12mm]
\doSimpleExercise{How many of these operations are performed in both cases?}
\end{frame}

\begin{frame}[fragile]{Exercises}
  
\begin{columns}
\begin{column}{0.48\textwidth}
\begin{lstlisting}[language=C++]
int mult1 (int x, int y){
  int a, b, r;
  a=x; b=y; r=0;
  while (a!=0){
    r = r+b;
    a = a-1;
  }
  return r;
}
\end{lstlisting}
\end{column}
\begin{column}{0.48\textwidth}
\begin{lstlisting}[language=C++]
int mult2 (int x, int y){
  int a, b, r;
  a=x; b=y; r=0;
  while (a!=0) {
    if (a%2 == 1) r = r+b;
    a=a/2;
    b=b*2;
  return r;
}
\end{lstlisting}
\end{column}
\end{columns}
\doSimpleExercise{In each case, how many primitive operations (\texttt{+ - *2 /2 \%2}) are performed?}
Note: In \texttt{mult2}, consider the size $N$ as the number of bits used to represent \texttt{x} and \texttt{y}; e.g., with 5 bits you can represent a positive integer until 31.

% Considere que o tamanho do input  ́e o nu ́mero de bits necess ́arios para representar os nu ́meros inteiros passados como argumento. Recorde que, por exemplo, os nu ́meros cuja representa ̧c ̃ao requer 5 bits s ̃ao {16, . . . , 31}.}
\end{frame}


\begin{frame}[fragile]\frametitle{Exercises}
\begin{columns}
\begin{column}{0.48\textwidth}
\begin{lstlisting}[language=C++,emph={maxgrow,grow}]
int maxgrow(int v[], int N) {
  int r = 1, i = 0, m;
  while (i<N-1) {
    m = grow(v+i, N-i);
    if (m>r) r = m;
    i++;
  }
  return r;
}
\end{lstlisting}
\end{column}
\begin{column}{0.48\textwidth}
\begin{lstlisting}[language=C++,emph={grow}]
int grow(int v[], int N) {
  int i;
  for (i=1; i<N; i++)
    if (v[i] < v[i-1]) break;
  return i;
}



\end{lstlisting}
\end{column}
\end{columns}

\doSimpleExercise{What is the best and worst case for \texttt{maxgrow} wrt comparisons of array elements?}
~\\[-10mm]
\doSimpleExercise{How many comparisons in each case?}

% Worst case when i+=m replaces i++?
\end{frame}


\section{Asymptotic Notation}

\byothers{Pedro Ribeiro, slides 2}{19-23}{ribeiro/2_asymptoticanalysis_02102018.pdf}

\begin{frame}[t]\frametitle{Examples}
    ~\\[-8mm]
    \begin{block}{Big Oh ($O$)}
        $3n^2 -100n+6 \only<1>{\alert{~{=}?~}}\only<2->{\alert<2>{=   }} O(n^2)$\only<2->{\structure<2>{ ~~because~~} $ 3n^2 >3n^2 -100n+6$}
      \\$3n^2 -100n+6 \only<1>{\alert{~{=}?~}}\only<2->{\alert<2>{=   }} O(n^3)$\only<2->{\structure<2>{ ~~because~~} $0.01n^3 >3n^2 -100n+6$}
      \\$3n^2 -100n+6 \only<1>{\alert{~{=}?~}}\only<2->{\alert<2>{\neq}} O(n)$  \only<2->{\structure<2>{~~~because~~} $c\cdot n<3n^2$ when $n>c$}
    \end{block}

    \begin{block}{Big Omega ($\Omega$)}
        $3n^2 -100n+6 \only<1-2>{\alert{~{=}?~}}\only<3->{\alert<3>{=   }} \Omega(n^2)$\only<3->{\structure<3>{ ~~because~~} $2.99n^2 <3n^2 -100n+6$}
      \\$3n^2 -100n+6 \only<1-2>{\alert{~{=}?~}}\only<3->{\alert<3>{\neq}} \Omega(n^3)$\only<3->{\structure<3>{ ~~because~~} $n^3 > 3n^2 -100n+6$}
      \\$3n^2 -100n+6 \only<1-2>{\alert{~{=}?~}}\only<3->{\alert<3>{=   }} \Omega(n)$  \only<3->{\structure<3>{~~~because~~} $10^{10^{10}} n < 3n^2 -100+6$}
    \end{block}

    \begin{block}{Big Theta ($\Theta$)}
        $3n^2 - 100n + 6 \only<1-3>{\alert{~{=}?~}}\only<4->{\alert<4>{=   }} \Theta(n^2)$\only<4->{\structure<4>{ ~~because~~} $O$ and $\Omega$}
      \\$3n^2 - 100n + 6 \only<1-3>{\alert{~{=}?~}}\only<4->{\alert<4>{\neq}} \Theta(n^3)$\only<4->{\structure<4>{ ~~because~~} $O$ only}
      \\$3n^2 - 100n + 6 \only<1-3>{\alert{~{=}?~}}\only<4->{\alert<4>{\neq}} \Theta(n)$  \only<4->{\structure<4>{~~~because~~} $\Omega$ only}
    \end{block}

\end{frame}

\byothers{Pedro Ribeiro, slides 2}{24-31}{ribeiro/2_asymptoticanalysis_02102018.pdf}


% \begin{frame}\frametitle{Exercises}

%   [WiP]

% \end{frame}

\byothers{Pedro Ribeiro, exercises 2}{1-2}{ribeiro/ex02.pdf}



\section{Analysis of recursive functions}

\begin{frame}[fragile]\frametitle{Binary search}

To analyse the complexity of a recursive function, we typically define the time $T$ using \emph{recurring equations}.

\begin{columns}
\begin{column}{0.48\textwidth}
\begin{lstlisting}[language=C++,emph={bsearch}]
int bsearch(int x, int v[], int N){
  int i;
  if (N<=0) i = -1;
  else {
    m = N/2;
    if (v[m]==x) i = m;
    else if (v[m] > x)
      i = bsearch(x, v, m);
    else {
      i = bsearch(x, v+m+1, N-m-1);
      if (i!=-1) i = i+m+1
    }
  return i ;
}
\end{lstlisting}
\end{column}
  \begin{column}{0.48\textwidth}
    \small
    \only<1>{Counting the number of comparisons with array elements:
    $$T(N) = \left\{\begin{array}{ll}
    0 & \text{if }N=0\\
    T(N/2)+2 & \text{if }N>0
    \end{array}\right.$$}
    \only<2->{
    (T(N) = T(N/2)+2~~if~~N>0)
    \begin{align*}
    T(0) &= 0\\
    T(1) &= T(2^0) = 2\\
    T(2) &= T(2^1) = 2+T({2}/{2}) = 2+2 = 4\\
    T(4) &= T(2^2) = 2+T({4}/{2}) = 2+2+2 = 6\\
    \cdots\\
    T(2^i) &= \underbrace{2+2+\cdots+2}_{i\text{-times}} + 2 = 2i+2
    \\
    \only<3>{T(N) &= T(2^{log_2(N)}) \\&= 2*log_2(N)+2 ~~~(= \Theta(log(N)))}
    \end{align*}
    }
  \end{column}
\end{columns}
\end{frame}

\byothers{Pedro Ribeiro, slides 2}{38-61}{ribeiro/2_asymptoticanalysis_02102018.pdf}


\begin{frame}[fragile]\frametitle{Exercises}

\doExercise{Solve using recursion trees (assume $T(0)$ is a constant)}{
  \small
  \begin{enumerate}
    \item $T(n)~=~k+T(n-1)$ ~~where $k$ is a constant
    \item $T(n)~=~k + T(n/2)$ ~~where $k$ is a constant
    \item $T(n)~=~k + 2 * T(n/2)$ ~~where $k$ is a constant
    \item $T(n)~=~n+T(n-1)$
    \item $T(n)~=~n + T(n/2)$
    \item $T(n)~=~n+2*T(n/2)$
  \end{enumerate}
}
\end{frame}

\begin{frame}\frametitle{Exercises}
[more exercises: maxSumR; hanoi; heightBT]
[maybe use PR's exercises too.]
\end{frame}


\byothers{Pedro Ribeiro, slides 2}{62-69}{ribeiro/2_asymptoticanalysis_02102018.pdf}

\begin{frame}\frametitle{Exercises}
\doSimpleExercise{Calculate the asymptotic complexity of the 3 exercises above (\texttt{maxSumR}, \texttt{hanoi}, and \texttt{heightBT}), indicating which case you used.}
    \end{frame}

% \begin{frame}[t]\frametitle{...}
    
% [example with merge sort; avoid substitution method (or glimpse for a given guess); focus on recurrent trees]

% [exercises both from Ribeiro and JBB]

% [Later: simplified version of master theorem and short exercises]

% \end{frame}



\section{Average case -- next slides}

\begin{frame}\frametitle{Recall goal}
    
...

\end{frame}


\begin{frame}\frametitle{Recall arithmetic series}
    
...

\end{frame}

\begin{frame}\frametitle{Recall geometric series}
    
...

\end{frame}



\end{document}
